\input{preamble.tex}
\usepackage{amsmath}

\Assignment{3}
\Deadline{March 5, 2023}
\begin{document}
\maketitle
\DEFAULTMSG{}

\begin{problem}
Consider the sequence of values $S = [12, 44, 13, 88, 23, 94, 11, 39, 20, 16, 5]$.
\begin{questions}

\item Draw the binary search tree obtained by adding the values in $S$ in sequence.

\begin{tikzpicture}
  \node[dot] (p) at (0, 0)       {};
  \node[dot] (l) at (-2, -1)     {}  edge[<-] (p);
  \node[dot] (ll) at (-3, -2)  {}  edge[<-] (l);
  \node[dot] (r) at (2, -1)     {}  edge[<-] (p);
  \node[dot] (rl) at (1, -2)  {}  edge[<-] (r);
  \node[dot] (rr) at (3, -2) {} edge[<-] (r);
  \node[dot] (rrr) at (3.5, -3) {} edge[<-] (rr);
  \node[dot] (rlr) at (1.5, -3) {} edge[<-] (rl);
  \node[dot] (rlrr) at (2, -4) {} edge[<-] (rlr);
  \node[dot] (rlrl) at (1, -4) {} edge[<-] (rlr);
  \node[dot] (rlrll) at (0.5, -5) {} edge[<-] (rlrl);

  \node[above left] at (p)  {12};
  \node[above left] at (l)  {11};
  \node[above left] at (ll) {5};
  \node[above right] at (r)  {44};
  \node[above left] at (rl) {13};
  \node[above right] at (rr) {88};
  \node[above right] at (rrr) {94};
  \node[above right] at (rlr) {23};
  \node[above right] at (rlrr) {39};
  \node[above left] at (rlrl) {20};
  \node[above left] at (rlrll) {16};
\end{tikzpicture}

\item Draw the red-black tree obtained by adding the values in $S$ in sequence.

\begin{tikzpicture}
  \node[dot] (p) at (0, 0)       {};
  \node[dot] (l) at (-2, -1)     {}  edge[<-] (p);
  \node[dot,cbReddischPurple] (ll) at (-3, -2)  {}  edge[<-,very thick,cbReddischPurple] (l);
  \node[dot] (lll) at (-3.5, -3) {}  edge[<-] (ll);
  \node[dot] (llr) at (-2.5, -3) {}  edge[<-] (ll);
  \node[dot] (lr) at (-1, -2)  {}  edge[<-] (l);
  \node[dot,cbReddischPurple] (lrl) at (-1.5, -3)  {}  edge[<-,very thick,cbReddischPurple] (lr);
  \node[dot] (r) at (2, -1)     {}  edge[<-] (p);
  \node[dot] (rl) at (1, -2)  {}  edge[<-] (r);
  \node[dot] (rr) at (3, -2) {} edge[<-] (r);
  \node[dot,cbReddischPurple] (rrl) at (2.5, -3) {} edge[<-,very thick,cbReddischPurple] (rr);


  \node[above left] at (p)  {23};
  \node[above left] at (l)  {13};
  \node[above left] at (ll) {11};
  \node[above left] at (lll) {5};
  \node[above right] at (llr) {12};
  \node[below right] at (lrl) {16};
  \node[above right] at (lr) {20};
  \node[above right] at (r)  {44};
  \node[above left] at (rl) {39};
  \node[above right] at (rr) {94};
  \node[above left] at (rrl) {88};
\end{tikzpicture}

\item Consider the hash-function $h(k) = (2k + 5) \bmod 11$ and a hash-table of $11$ table entries that uses hashing with separate chaining. Draw the hash-table obtained by adding the values in $S$ in sequence.

\begin{tikzpicture}
  \node[hlisted=11,text width=1cm] (ar) {
  \Null{}
  \nodepart{two}\At{A128}
  \nodepart{three}\Null{}
  \nodepart{four}\Null{}
  \nodepart{five}\At{C923}
  \nodepart{six}\At{9D21}
  \nodepart{seven}\At{ADF3}
  \nodepart{eight}\At{F923}
  \nodepart{nine}\Null{}
  \nodepart{ten}\At{E00F}
  \nodepart{eleven}\Null{}};
  
  \node[above] at (ar.north) {$L[0\dots11)$:};
  \node[left] at (ar.one west) {0:};
  \node[left] at (ar.two west) {1:};
  \node[left] at (ar.three west) {2:};
  \node[left] at (ar.four west) {3:};
  \node[left] at (ar.five west) {4:};
  \node[left] at (ar.six west) {5:};
  \node[left] at (ar.seven west) {6:};
  \node[left] at (ar.eight west) {7:};
  \node[left] at (ar.nine west) {8:};
  \node[left] at (ar.ten west) {9:};
  \node[left] at (ar.eleven west) {10:};


  \node[lnode,right=0.4cm,yshift=0cm,scale=0.65] (n3) at (ar.one east) {item: {20}\nodepart{two}next: \Null};
  \node[above right,scale=0.65] at (n3.north west) {\At{A128}:};
  \path (ar.two east) edge[->] (n3.north west);




  \node[lnode,right=0.4cm,yshift=0cm,scale=0.65] (n1) at (ar.three east) {item: {5}\nodepart{two}next: \At{312C}};
  \node[above right,scale=0.65] at (n1.north west) {\At{C923}:};
  \path (ar.five east) edge[->] (n1.north west);

  \node[lnode,right=0.4cm,scale=0.65] (n2) at (n1.east) {item: {16}\nodepart{two}next: \Null};
  \node[above right,scale=0.65] at (n2.north west) {\At{312C}:};
  \draw[->] (n1.two east) -| ($(n1.text split)!0.5!(n2.text split)$) |- (n2.north west);




  \node[lnode,right=0.4cm,yshift=0cm,scale=0.65] (n4) at (ar.five east) {item: {11}\nodepart{two}next: \At{1D23}};
  \node[above right,scale=0.65] at (n4.north west) {\At{9D21}:};
  \path (ar.six east) edge[->] (n4.north west);

  \node[lnode,right=0.4cm,scale=0.65] (n5) at (n4.east) {item: {88}\nodepart{two}next: \At{5283}};
  \node[above right,scale=0.65] at (n5.north west) {\At{1D23}:};
  \draw[->] (n4.two east) -| ($(n4.text split)!0.5!(n5.text split)$) |- (n5.north west);

  \node[lnode,right=0.4cm,scale=0.65] (n6) at (n5.east) {item: {44}\nodepart{two}next: \Null};
  \node[above right,scale=0.65] at (n6.north west) {\At{5283}:};
  \draw[->] (n5.two east) -| ($(n5.text split)!0.5!(n6.text split)$) |- (n6.north west);



  \node[lnode,right=0.4cm,yshift=0cm,scale=0.65] (n7) at (ar.seven east) {item: {39}\nodepart{two}next: \At{DE92}};
  \node[above right,scale=0.65] at (n7.north west) {\At{ADF3}:};
  \path (ar.seven east) edge[->] (n7.north west);

  \node[lnode,right=0.4cm,scale=0.65] (n8) at (n7.east) {item: {94}\nodepart{two}next: \Null};
  \node[above right,scale=0.65] at (n8.north west) {\At{DE92}:};
  \draw[->] (n7.two east) -| ($(n7.text split)!0.5!(n8.text split)$) |- (n8.north west);
  



  \node[lnode,right=0.4cm,yshift=0cm,scale=0.65] (n9) at (ar.nine east) {item: {23}\nodepart{two}next: \At{6A43}};
  \node[above right,scale=0.65] at (n9.north west) {\At{F923}:};
  \path (ar.eight east) edge[->] (n9.north west);

  \node[lnode,right=0.4cm,scale=0.65] (n10) at (n9.east) {item: {12}\nodepart{two}next: \Null};
  \node[above right,scale=0.65] at (n10.north west) {\At{6A43}:};
  \draw[->] (n9.two east) -| ($(n9.text split)!0.5!(n10.text split)$) |- (n10.north west);



  \node[lnode,right=0.4cm,yshift=0cm,scale=0.65] (n11) at (ar.eleven east) {item: {13}\nodepart{two}next: \Null};
  \node[above right,scale=0.65] at (n11.north west) {\At{E00F}:};
  \path (ar.ten east) edge[->] (n11.north west);

\end{tikzpicture}

\item Consider the hash-function $h(k) = (3k + 2) \bmod 11$ and a hash-table of $11$ table entries that uses hashing with linear probing. Draw the hash-table obtained by adding the values in $S$ in sequence.

\begin{tikzpicture}
  \node[hlisted=11,text width=1cm] (ar) {
  16
  \nodepart{two}5
  \nodepart{three}44
  \nodepart{four}88
  \nodepart{five}11
  \nodepart{six}12
  \nodepart{seven}23
  \nodepart{eight}20
  \nodepart{nine}13
  \nodepart{ten}94
  \nodepart{eleven}39};
  
  \node[above] at (ar.north) {$L[0\dots11)$:};
  \node[left] at (ar.one west) {0:};
  \node[left] at (ar.two west) {1:};
  \node[left] at (ar.three west) {2:};
  \node[left] at (ar.four west) {3:};
  \node[left] at (ar.five west) {4:};
  \node[left] at (ar.six west) {5:};
  \node[left] at (ar.seven west) {6:};
  \node[left] at (ar.eight west) {7:};
  \node[left] at (ar.nine west) {8:};
  \node[left] at (ar.ten west) {9:};
  \node[left] at (ar.eleven west) {10:};

\end{tikzpicture}

\end{questions}
\end{problem}


\begin{problem}
We say that a hash function $h : \mathcal{U} \rightarrow \mathbb{N}$ that maps values from a set $\mathcal{U}$ to integers in the range $[0\dots M)$ is \emph{$n$-perfect} if there exists at most $n$ distinct values $u_1, \dots, u_j \in \mathcal{U}$ such that $h(u_1) = \dots = h(u_j)$.
\begin{questions}
\item Consider the hash function $h(k) = (2k + 5) \bmod 11$. Is this hash function $2$-perfect for the inputs $0, \dots, 21$? Explain why or why not.

\textbf{Answer:}
This function is 2-perfect for the inputs 0,...,21 since after computation, there is only 2 values mapped to one spot in the hash table. In summary, since the function has 2k, as you loop through the values, the new value will most often be 2 more than the previous. This is until you hit 11 as it is mod 11, then it will start back at either 0 or 1 depending on if the previous value was 9 or 10. The following is the computation.\\

\begin{center}
  \begin{tabular}{||c|c|c|c|c|c|c|c||} 
    \hline
    v & h(v)=(2v+5)mod 11 & v & h(v) & v & h(v) & v & h(v) \\ [0.5ex] 
    \hline\hline
    0 & 5 & 6 & 6 & 12 & 7 & 18 & 8\\ 
    1 & 7 & 7 & 8 & 13 & 9 & 19 & 10 \\
    2 & 9 & 8 & 10 & 14 & 0 & 20 & 1 \\
    3 & 0 & 9 & 1 & 15 & 2 & 21 & 3 \\
    4 & 2 & 10 & 3 & 16 & 4 &  & \\
    5 & 4 & 11 & 5 & 17 & 6 &  & \\ [1ex] 
    \hline
  \end{tabular}
\end{center}

Rearrange to see that there are only two values per mapping. We can see that if there was 1 more value, it would no longer be 2-perfect:

\begin{center}
  \begin{tabular}{||c|c|c|c|c|c|c|c||} 
    \hline
    h(v) & v & h(v) & v & h(v) & v & h(v) & v \\ [0.5ex] 
    \hline\hline
    0 & 3, 14 & 3 & 10, 21 & 6 & 6, 17 & 9 & 13, 2\\ 
    1 & 9, 20 & 4 & 5, 16 & 7 & 12, 1 & 10 & 8, 19 \\
    2 & 4, 15 & 5 & 11, 0 & 8 & 7, 18 &  &  \\ [1ex] 
    \hline
  \end{tabular}
\end{center}


\item Prove that a hash function $h : \mathcal{U} \rightarrow \mathbb{N}$ can only be $n$-perfect if $\abs{\mathcal{U}} \leq n \cdot M$.

\textbf{Answer:}

Assume $h : \mathcal{U} \rightarrow \mathbb{N}$ is n-perfect and let 
$u_1, \dots, u_j$ be j distinct values in $\mathcal{U}$ such that $h(u_1) = \dots = h(u_j)$. Then we will have that $j \leq n$.

$\mathcal{S}_i = \{x \in \mathcal{U}\:|\:h(x) = i\}$ --> In other words, $\mathcal{S}_i$ has elements in $\mathcal{U}$ that map to $i$

This means, $\mathcal{U} = \sum_{i=0}^{M-1} \mathcal{S}_i$ where $|\mathcal{U}| = M$

since $h$ is n-perfect, we know $|\mathcal{S}_i| \leq n$

$\mathcal{U} = \sum_{i=0}^{M-1} \mathcal{S}_i$\\
$|\mathcal{U}| = |\sum_{i=0}^{M-1} \mathcal{S}_i|$\\
$ = \sum_{i=0}^{M-1} |\mathcal{S}_i|$\\
$ \leq \sum_{i=0}^{M-1} n$\\
$ = nM $\\

In conclusion, we have proven that assuming $h : \mathcal{U} \rightarrow \mathbb{N}$ is a n-perfect hash function, then $|\mathcal{U}| \leq nM$ holds.

As we provided an upper bound on the number of elements in $\mathcal{U}$ that can be hashed without collisions, we know that adding any more elements will result in more than n values being mapped to a single hash value, which violates n-perfect rules.

\item Can a general purpose hash function be $n$-perfect for any $M$? Argue why or why not.

\textbf{Answer: }

No a general-purpose hash function cannot be n-perfect for any M because a general-purpose hash function must be able to take in any set of input and ensure each hash value contains $\leq n$ values from the input. 
This means it needs to handle inputs such as lists that have near infinity values (huge M), which is impossible to be n-perfect as you'd have to have an unrealistic number of spots in the hash-table to put the values in.

Mathematically, the Probability a value $V_r$ in the input set collides with a previously hashed value is:

Probability($V_r$ collides with $V_1$) $\cdot$ Probability($V_r$ collides with $V_2$) $\cdot \dots$ Probability($V_r$ collides with $V_{r-1}$)

1/M + 2/M + 3/M... n/M, where n is the $n_{th}$ element in the input list.

FIX THISSSSSSSSSSSSSSSSSSSSSS

the probability to have a collision is $\sim 1 - \frac{n}{M}$

\end{questions}
\end{problem}

\begin{problem}
Consider non-empty binary search trees $T_1$ and $T_2$ such that all values in $T_1$ are smaller than the values in $T_2$. The \AName{SetUnion} operation takes binary search trees $T_1$ and $T_2$ and returns a binary search trees holding all values originally in $T_1$ and $T_2$ (destroying $T_1$ and $T_2$ in the process). 
\begin{questions}
\item Assume the binary search trees storing $T_1$ and $T_2$ have the same height $h$. Show how to implement the \AName{SetUnion} operation in $\OOG{h}$ such that the resulting tree has a height of at-most $h+1$.

- Remove max value in $T_1$ and store it in variable m\\
$h$ is worst-case time complexity, where the max value is at the $h_{th}$ level in the tree. $T_1$ will still have a height of $h$ or $h-1$ if max value m was the only value in level $h$ of the tree.

- Add the max value m as the root of $T_1$\\
$\sim 1$ time complexity, as it just takes a little pointer logic. Make m node root of $T_1$ and make m.left be the old root of $T_1$. This will lead the tree be max height $h+1$ as we are only added 1 level (the new root) to the tree.
Also, we know all values in $T_1$ are smaller than m, so BST properties remain as we add $T_1$ as the left subtree of the new root, m.
At this point, $T_1$ is of height $ \leq h+1$ and $T_2$ is of height $h$

- Take the root of $T_2$ and make it right subtree of new $T_1$\\
Again $\sim 1$ time complexity, as it just requires to make m.right $ = T_2$. We know the left subtree of m is max $h$ height and the right subtree is $h$ since we just added $T_2$ which is a tree of height $h$.
We also know that all values in $T_2$ are greater than the values in the current $T_1$, including the root. This allows us to put the root of $T_2$ as the right child of m, ensuring we keep BST properties.

- return $T_1$\\

To conclude, the resulting tree will be of height $h+1$ since we took 2 tree of height $h$ and added 1 level to it (the root). We also know it keeps BST properties as we know all values in $T_2$ are larger than the maximum value in $T_1$, which allows us to put $T_2$ in the right subtree of the root of new $T_1$

\item Assume that $T_1$ and $T_2$ are red-black trees with the same black height $h$. Show how to implement a \AName{SetUnion} operation that returns a red-black tree in $\OOG{h}$.



\item Assume that $T_1$ and $T_2$ are red-black trees with black heights $h_1 > h_2$. Show how to implement a \AName{SetUnion} operation that returns a red-black tree in $\OOG{h_1}$.



\end{questions}
\end{problem}


\begin{problem}
Consider \emph{binary strings} (sequences of zeros and ones). 
\begin{questions}
\item Design a data structure \AName{BSSet} that can be used to represent \emph{sets of binary strings} such that any binary string $W$ of length $\abs{W} = N$ can be added or removed in $\OOG{N}$ and such that one can check whether $W$ is in the data structure in $\OOG{N}$. Sketch why your data structure  \AName{BSSet} supports the stated operations in $\OOG{N}$.
\item Let $W$ of length $\abs{W} = N$ be a binary string and let $S$ be a \AName{BSSet} set. Provide an algorithm that prints all strings $V \in S$ that start with the prefix $W$ (the first $\abs{W}$ characters of $S$ are equivalent to $W$). Your algorithm should have a worst-case complexity of $\OOG{N + k}$ in which $k$ is the number of characters printed to the output.
\item Professor X claims to have developed a data structure \AName{BSSetX} to which any binary string $W$ of length $\abs{W} = N$ can be added in $\OOG{N}$. Furthermore, Professor X claims that \AName{BSSetX}  provides \emph{ordered iteration}: one can iterate over all $M = \abs{S}$ strings in a set $S$, implemented via \AName{BSSetX}, in a lexicographical order in $\OOG{M + T}$ in which $T$ is the combined length of the $M$ strings. Professor X claims that this method of sorting binary strings proves that the worst-case lower bound for sorting $M$ binary strings is \emph{not} $\OOG{M \log_2(M)}$ comparisons. Argue why Professor X is wrong.

We note that strings $S_1$ and $S_2$ are \emph{lexicographical ordered}, denoted by $S_1 \prec S_2$, if $S_1$ comes before $S_2$ in an alphabetical sort (e.g., as used in a dictionary). Next, we formalize $S_1 \prec S_2$ for binary strings: we have $S_1 \prec S_2$ if $S_1$ and $S_2$ are equivalent up to the $0\leq i \leq \min(\abs{S_1}, \abs{S_2})$-th character ($S_1[0] = S_2[0]$,
\dots, $S_1[i-1] = S_2[i-1]$) and either $\abs{S_1} = i < \abs{S_2}$ or the $(i+1)$-th character of $S_1$ comes before the $(i+1)$-th character of $S_2$ (in which case $S_1[i] = 0$ and $S_2[i] = 1$). For example, $0 \prec 00$ and $00 \prec 01$, but not $100 \prec 10$. 
\end{questions}
\end{problem}

\SUBMITMSG{}
\DEFAULTGRADING{}

\end{document}