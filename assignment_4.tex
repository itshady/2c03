\input{preamble.tex}

\Assignment{4}
\Deadline{March 19, 2023}
\begin{document}
\maketitle
\DEFAULTMSG{}

\begin{problem}
Consider a directed graph $\Graph = (\Nodes, \Edges)$. Breadth-first search and depth-first search both have a runtime complexity of $\OOG{\abs{\Nodes} + \abs{\Edges}}$ if we represent the graph with an adjacency list.
\begin{questions}
\item What is the runtime complexity of breadth-first search and depth-first search when we use the matrix representation? Explain your answer.

For BFS, we typically use a queue to store the vertices to be 
processed. In each iteration, we remove a vertex from the front 
of the queue, add its neighbors to the back of the queue if they 
have not been visited yet, and mark the removed vertex as visited.
 To determine the neighbors of a vertex, we need to examine the
  corresponding row of the adjacency matrix. Thus, for each 
  vertex, we need to scan the corresponding row of the adjacency
   matrix to find its neighbors. Since there are $|N|$ vertices, 
   each with $|N|$ entries in the adjacency matrix, the time 
   complexity of BFS using the adjacency matrix representation 
   is $O(|N|^2)$.

For DFS, we typically use a stack to store the vertices to 
be processed. In each iteration, we remove a vertex from the 
top of the stack, add its unvisited neighbors to the stack, and 
mark the removed vertex as visited. To determine the neighbors 
of a vertex, we need to examine the corresponding row of the 
adjacency matrix. Thus, for each vertex, we need to scan the 
corresponding row of the adjacency matrix to find its neighbors. 
Since there are $|N|$ vertices, each with $|N|$ entries in the
 adjacency matrix, the time complexity of DFS using the adjacency 
 matrix representation is also $O(|N|^2)$.

\item Consider the \emph{ordered edge list} representation that represents a graph by an \emph{ordered} array $A$ that holds $\abs{\Edges}$ edges. The order of edges is as follows: edge $(n_1, m_1) \in A$ comes before $(n_2, m_2) \in A$ if $\ID{n_1} < \ID{n_2}$ or if $\ID{n_1} = \ID{n_1} \land \ID{m_1} \leq \ID{m_2}$. What is the runtime complexity of breadth-first search and depth-first search when we use the \emph{ordered edge list} representation? Explain your answer.


In the ordered edge list represenation, since edges are sorted, we know all edges that start at $n_1$ will be at the start of the array, followed by $n_2$ and so on. We can then use binary search to find the first edge of the list of edges that start at $n_x$ where x is the node number. 

For BFS, we know that we traverse every node once and every edge once (covered in class). Basically, we start by visiting the start node and then all its neighbours. To visit its neighbours, we need to search for the edges that have the starting node as the first node in the tuple. To find these nodes, it takes $\OOG{log_2{|E|}}$ time where the length of the list to search is $|E|$. We repeat this process for every node, meaning we visit every node once and every edge once and need to call a $\OOG{log_2{|E|}}$ operation once per node. This gives a complexity of $\OOG{|N|log_2|E| + |E|}$.

For DFS, we also know that we traverse every node and edge once. We do this by starting at the start node and recursively visiting all its neighbours. Again, to visit the neighbours will require to find the edges in the ordered list, which requires the binary search of $\OOG{log_2{|E|}}$. We repeat this process for all nodes that are visited, thus meaning we use the binary search once per node. Since this is the case, the overall runtime complexity is also $\OOG{|N|log_2|E| + |E|}$ as we traverse every node and edge once and for every node, need to perform a $\OOG{log_2{|E|}}$ complexity search.

\end{questions}
\end{problem}

\begin{problem}
Consider a directed acyclic graph $\Graph = (\Nodes, \Edges)$ with a source node $m \in \Nodes$ and target node $n \in \Nodes$.
\begin{questions}
\item Provide an algorithm that computes the number of paths starting at $m$ and ending at $n$.

Assuming an adjacency representation of the graph.

\begin{myalgo}{\AName{DFS}($\VAR{start},\VAR{dest},\VAR{storedPaths}$)}
  \IF{$\VAR{start}=1$}
    \RETURN 1
  \ENDIF
  \STATE $path = 0$
  \FOR{$n \in \VAR{adj[start]}$}
    \IF{$(storedPaths.containsKey(n))$}
      \STATE $path += storedPaths.get(n)$
    \ELSE{}
      \STATE $\VAR{paths} += $\AName{DFS}($\VAR{start},\VAR{dest},\VAR{storedPaths}$)
    \ENDIF
  \ENDFOR
  \STATE $storedPaths.putIfAbsent(v, path)$
  \RETURN $paths$
\end{myalgo}

Call this via 

\begin{myalgo}{\AName{Main}()}
  \STATE $graph \GETS new Graph()$  \COMMENT{initialized graph with edges and nodes already set}
  \STATE $Map<Integer, Integer> storedPaths = new HashMap<>()$
  \PRINT \AName{DFS}($start\_node\_id,destination\_node\_id,storedPaths$)
\end{myalgo}

Graph representation: adjacency representation. The algorithm runs DFS from the start node. For each node in its adjacency list (neighbours), it runs another DFS. This happens recursively.
This algorithm goes over what is considered a "marked node" in normal DFS as we want to account for every single path, not only unique ones. Each DFS counts the number of paths to the destination node by summing the number of paths to the destination node all of its children have.
The base case is when reaching the destination node, we have 1 path. Using this recursion, we can sum all the paths to the destination node and return that.

As I use dynamic programming to keep track of the solution to "subproblems" (a subproblem being finding the paths to the destination node from specific node), we only ever need to compute the number of paths from a single node to the destination once. After that we can fetch that result from the storedPaths map.
This means that for every node, we perform a DFS. We know DFS using adjacency represenation is $\OOG{|N| + |E|}$, so if we do this for each node, the complexity is $\OOG{|N|^2 + |N||E|}$

\item We say that the directed acyclic graph $\Graph$ has a \emph{bottleneck} if there is a node $b$, distinct from source $m$ and target $n$, such that all paths from $m$ to $n$ go through node $b$. Write an algorithm that returns $\True$ if  and only if $\Graph$ has such a bottleneck. You may assume that there is at-least one path from $m$ to $n$.

\begin{myalgo}{\AName{Bottleneck}($\VAR{m},\VAR{n}$)}
  \STATE $G = Graph(V,E)$  \COMMENT{Initialized graph with all nodes V and edges E}
  \STATE $S = G.DFS(m)$ \COMMENT{All nodes reachable from m}
  \STATE $G_{rev} = (V, {e \in G | (n_1,n_2) \in E : (n_2,n_1)})$  \COMMENT{Same graph, but with all edges flipped}
  \STATE $T = G_{rev}.DFS(n)$ \COMMENT{All nodes that can reach n}
  \STATE $B = Intersection(S,T)$ \COMMENT{All nodes that are reachable from m and can reach n}
  \FOR{$x \in B$}
    \IF{$G.AllPathsContain(m,n,x) == false$} 
      \STATE $B.remove(x)$  \COMMENT{Traverse all paths from m to n, and if it doesn't pass x, remove x from B}
    \ENDIF
  \ENDFOR
  \IF{$B.empty$}
    \RETURN FALSE
  \ENDIF
  \RETURN TRUE
\end{myalgo}

I am using adjacency representation again.

DFS on line 2: Is a $\mathcal{O}(\OOG{|N|+|E|})$ as it is a normal DFS where we keep track of the nodes reachable from m and return them. As mentioned in lecture, DFS is $\mathcal{O}(\OOG{|N|+|E|})$.

Reversing the edges on line 3: Is a $\mathcal{O}(\OOG{|E|})$ as you need to swap the nodes for every edge.

DFS on line 4: With the reverse graph, do the same as line 2 where you find all reachable nodes. This will get all nodes that can reach n in $\mathcal{O}(\OOG{|N|+|E|})$.

Intersection on line 5: Goes through all of $S$ and $T$ and adds nodes that are in both sets. This is $\mathcal{O}(\OOG{|N|})$ as worst-case, all nodes are in both sets, so we must traverse the sets fully.

Traverse paths of lines 6-10: For every node in $B$, which we determined worst-case is $|N|$ nodes, we must traverse all paths, which can again be accomplished using DFS, which is $\mathcal{O}(\OOG{|N|+|E|})$. Thus the complexity here is $\mathcal{O}(\OOG{|N|^2+|N||E|})$

Removing from B is an $\mathcal{O}(\OOG{|B|})$, which is worst-case $\mathcal{O}(\OOG{|N|})$, and checking if B is empty is $\mathcal{O}(\OOG{1})$.

Thus we can see, lines 6-10 are the largest complexity, so the overall complexity for this algorithm is $\mathcal{O}(\OOG{|N|^2+|N||E|})$

\end{questions}
For each question, explain why your algorithm is correct, what the complexity of your algorithm is, and which graph representation you use.
\end{problem}

\begin{problem}
Let $n$ be a positive integer and consider two $n \times n$ matrices $M_1$ and $M_2$. The \emph{Boolean matrix product} of $M_1$ and $M_2$, denoted by $M' \GETS M_1 \otimes M_2$, is the $n \times n$ matrix $M'$ in which $M'[i, j]$ is:
\[ M'[i, j] = (M_1[i, 0] \land M_2[0, j]) \lor (M_1[i, 1] \land M_2[1, j]) \lor \dots \lor (M_1[i, n-1] \land M_2[n-1,j]). \]

Now consider a directed graph $\Graph = (\Nodes, \Edges)$ implemented via the matrix representation $M$ with $n = \abs{\Nodes}$.
\begin{questions}
\item Let $M' = M \otimes M$. What does the value $M'[i,j]$ represent (when is it $\True$ and when is it $\False$)?

The value $M'[i, j]$ represents whether there exists a path of length 2 from node $i$ to node $j$ in the directed graph G = (N, E) represented by matrix M.

In other words, $M'[i, j]$ is true iff there exists a node $k$ such that $M[i, k]$ and $M[k, j]$ are true. This node $k$ is an intermediate node that connects $i$ and $j$.

If there is no node $k$ that can connect $i$ and $j$, then $M'[i, j]$ is false.

\item Consider paths of length $k$ in graph $G$. Provide an algorithm that uses the Boolean matrix product operations to compute a matrix $M_k$ such that, for every pair of nodes $n, m \in \Nodes$, $M_k[\ID{n}, \ID{m}]$ is $\True$ if and only if there is a path of length exact-$k$ from node $n$ to node $m$. Explain why your algorithm is correct and provide the complexity of your algorithm in terms of the number of Boolean matrix product operations used.

\textit{Hint}. One can design an algorithm that performs at-most $\OOG{\log_2(k)}$ Boolean matrix product operations.

Assuming the graph is in matrix representation.

Base case: If k = 1, then just return $M$ where $M_1[i,j]$ is 1 if there is an edge from node i to j. 

General case: If k > 1, recursively compute $M_{\lfloor{k/2}\rfloor}$, and then set $M_k$ to be the Boolean matrix product of $M_{\lfloor{k/2}\rfloor}$ and itself ($M_k = M_{\lfloor{k/2}\rfloor} \otimes M_{\lfloor{k/2}\rfloor}$).
If $k/2$ had a remainder, than after computing $M_{k2} = M_{\lfloor{k/2}\rfloor} \otimes M_{\lfloor{k/2}\rfloor}$, compute $M_k = M_{k2} \otimes M_1$.

In other words, the Boolean matrix product of $M_p \otimes M_r = M_{p+r}$.


\begin{myalgo}{\AName{BooleanProduct}($M, k$)}
  \IF{$k == 1$}
    \RETURN $M$
  \ENDIF
  \STATE $h = k//2$
  \STATE $M_h = \AName{BooleanProduct}(M, h)$
  \STATE $result = M_h \otimes M_h$ \COMMENT{Get Boolean Product of matrix}
  \IF{$h \% 2 == 1$}  
    \STATE $result \otimes M$ \COMMENT{If needed to floor the value, then compute the result with $M_1$ to add 1 to path length}
  \ENDIF
  \RETURN $result$
\end{myalgo}

Complexity: The complexity is $\OOG{log_2{k}}$ as you just divide the problem into 2 recursively until hitting the base case of 1.

When k is even, we compute $M_{\frac{k}{2}}$ by splitting the paths of length k into two subpaths of length k/2. 
When k is odd, we first compute $M_{k-1}$ for to find paths of length k-1, and then multiplying by $M_1$ to extend the paths by one edge.


\item The \emph{transitive closure} of $\Graph$ is a graph $\Graph' = (\Nodes, \Edges')$ such that $(n, m) \in \Edges'$ if and only if there is a path from node $n$ to node $m$ in graph $\Graph$. Provide an algorithm that uses the Boolean matrix product operations to compute a matrix $M'$ that represents graph $\Graph'$. Explain why your algorithm is correct and provide the complexity of your algorithm.

1. Create results matrix $N$ (initialized to all false) and OR it with matrix $M$. By OR, it means $N[i,j] = N[i,j] | M[i,j]$

2. Compute the Boolean matrix product $M' = M \otimes M$.

3. Store edges of $M'$ in the results Matrix $N$.

4. Repeat the matrix multiplication $M' = M' \otimes M$ until $M'$ stops changing. Keep storing the edges in results Matrrix between each multiplication.

5. The results Matrix $M'$ is the transitive closure of G.

Complexity is as large as the longest path since each matrix multiplication adds 1 to the path. This means $\OOG{\mathcal{O}(|N-1|)}$. 
This is added to the complexity of getting all edges in $M'$ and storing them in a resulting Matrix. Transferring this data is $\OOG{\mathcal{O}(|N|^2)}$ since you need to check every edge in $M'$.

WRONG BC THERE COULD BE CYCLES

\end{questions}
\end{problem}

\begin{problem}
Consider a directed graph $\Graph = (\Nodes, \Edges)$ and assume we have a weight function $\Weight : \Edges \rightarrow \{1, \dots, W\}$ with $W$ some maximum integer value $W$.
\begin{questions}
\item Assume $W = 1$ (all edges have weight $1$). Given node $n \in \Nodes$, provide an algorithm that can compute the shortest path from node $n$ to any other node $m$ in $\OOG{\abs{\Nodes} + \abs{\Edges}}$. In this case, the shortest path is the path with the fewest edges.

\begin{myalgo}{\AName{SSSP}($G, s$)}
  \STATE $predecessors = \{n -> \:? | n \in \mathcal{N}\}$
  \STATE $distance[s] = s$
  \STATE $Q = a queue$
  \STATE $ENQUEUE(Q, s)$
  \WHILE{$!EMPTY(Q)$}
    \STATE $n = DEQUEUE(Q)$
    \FORALL{ $(n,m) \in \Edges$}
      \IF{$predecessors[m] = \: ?$}
        \STATE $predecessors[m] = n$
        \STATE $ENQUEUE(Q, m)$
      \ENDIF
    \ENDFOR
  \ENDWHILE
  \RETURN $predecessors$
\end{myalgo}

Complexity: We inspect each node once and traverse each edge once making it $\OOG{\abs{\Nodes} + \abs{\Edges}}$ complexity.

\item Given node $n \in \Nodes$, provide an algorithm that can compute the shortest path (in terms of the sum of the weights of edges on the path) from node $n$ to any other node $m$ in $\OOG{\abs{\Nodes} + W\abs{\Edges}}$.


\item Given node $n \in \Nodes$, provide an algorithm that can compute the shortest path (in terms of the sum of the weights of edges on the path) from node $n$ to any other node $m$ in $\OOG{W\abs{\Nodes} + \abs{\Edges}}$.


\end{questions}
For each question, explain why your algorithm is correct, why your algorithm achieves the stated complexity, and which graph representation you use.
\end{problem}

\SUBMITMSG{}
\DEFAULTGRADING{}

\end{document}