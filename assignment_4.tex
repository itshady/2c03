\input{preamble.tex}

\Assignment{4}
\Deadline{March 19, 2023}
\begin{document}
\maketitle
\DEFAULTMSG{}

\begin{problem}
Consider a directed graph $\Graph = (\Nodes, \Edges)$. Breadth-first search and depth-first search both have a runtime complexity of $\OOG{\abs{\Nodes} + \abs{\Edges}}$ if we represent the graph with an adjacency list.
\begin{questions}
\item What is the runtime complexity of breadth-first search and depth-first search when we use the matrix representation? Explain your answer.
\item Consider the \emph{ordered edge list} representation that represents a graph by an \emph{ordered} array $A$ that holds $\abs{\Edges}$ edges. The order of edges is as follows: edge $(n_1, m_1) \in A$ comes before $(n_2, m_2) \in A$ if $\ID{n_1} < \ID{n_2}$ or if $\ID{n_1} = \ID{n_1} \land \ID{m_1} \leq \ID{m_2}$. What is the runtime complexity of breadth-first search and depth-first search when we use the \emph{ordered edge list} representation? Explain your answer.
\end{questions}
\end{problem}

\begin{problem}
Consider a directed acyclic graph $\Graph = (\Nodes, \Edges)$ with a source node $m \in \Nodes$ and target node $n \in \Nodes$.
\begin{questions}
\item Provide an algorithm that computes the number of paths starting at $m$ and ending at $n$.

Assuming an adjacency representation of the graph.

\begin{myalgo}{\AName{DFS}($\VAR{start},\VAR{dest},\VAR{storedPaths}$)}
  \IF{$\VAR{start}=1$}
    \RETURN 1
  \ENDIF
  \STATE $path = 0$
  \FOR{$n \in \VAR{adj[start]}$}
    \IF{$(storedPaths.containsKey(n))$}
      \STATE $path += storedPaths.get(n)$
    \ELSE{}
      \STATE $\VAR{paths} += $\AName{DFS}($\VAR{start},\VAR{dest},\VAR{storedPaths}$)
    \ENDIF
  \ENDFOR
  \STATE $storedPaths.putIfAbsent(v, path)$
  \RETURN $paths$
\end{myalgo}

Call this via 

\begin{myalgo}{\AName{Main}()}
  \STATE $graph \GETS new Graph()$  \COMMENT{initialized graph with edges and nodes already set}
  \STATE $Map<Integer, Integer> storedPaths = new HashMap<>()$
  \PRINT \AName{DFS}($start\_node\_id,destination\_node\_id,storedPaths$)
\end{myalgo}

Graph representation: adjacency representation. The algorithm runs DFS from the start node. For each node in its adjacency list (neighbours), it runs another DFS. This happens recursively.
This algorithm goes over what is considered a "marked node" in normal DFS as we want to account for every single path, not only unique ones. Each DFS counts the number of paths to the destination node by summing the number of paths to the destination node all of its children have.
The base case is when reaching the destination node, we have 1 path. Using this recursion, we can sum all the paths to the destination node and return that.

As I use dynamic programming to keep track of the solution to "subproblems" (a subproblem being finding the paths to the destination node from specific node), we only ever need to compute the number of paths from a single node to the destination once. After that we can fetch that result from the storedPaths map.
This means that for every node, we perform a DFS. We know DFS using adjacency represenation is $\OOG{|N| + |E|}$, so if we do this for each node, the complexity is $\OOG{|N|^2 + |N||E|}$

\item We say that the directed acyclic graph $\Graph$ has a \emph{bottleneck} if there is a node $b$, distinct from source $m$ and target $n$, such that all paths from $m$ to $n$ go through node $b$. Write an algorithm that returns $\True$ if  and only if $\Graph$ has such a bottleneck. You may assume that there is at-least one path from $m$ to $n$.

\begin{myalgo}{\AName{Bottleneck}($\VAR{m},\VAR{n}$)}
  \STATE $G = Graph(V,E)$  \COMMENT{Initialized graph with all nodes V and edges E}
  \STATE $S = G.DFS(m)$ \COMMENT{All nodes reachable from m}
  \STATE $G_{rev} = (V, {e \in G | (n_1,n_2) \in E : (n_2,n_1)})$  \COMMENT{Same graph, but with all edges flipped}
  \STATE $T = G_{rev}.DFS(n)$ \COMMENT{All nodes that can reach n}
  \STATE $B = Intersection(S,T)$ \COMMENT{All nodes that are reachable from m and can reach n}
  \FOR{$x \in B$}
    \IF{$G.AllPathsContain(m,n,x) == false$} 
      \STATE $B.remove(x)$  \COMMENT{Traverse all paths from m to n, and if it doesn't pass x, remove x from B}
    \ENDIF
  \ENDFOR
  \IF{$B.empty$}
    \RETURN FALSE
  \ENDIF
  \RETURN TRUE
\end{myalgo}

I am using adjacency representation again.

DFS on line 2: Is a $\mathcal{O}(\OOG{|N|+|E|})$ as it is a normal DFS where we keep track of the nodes reachable from m and return them. As mentioned in lecture, DFS is $\mathcal{O}(\OOG{|N|+|E|})$.

Reversing the edges on line 3: Is a $\mathcal{O}(\OOG{|E|})$ as you need to swap the nodes for every edge.

DFS on line 4: With the reverse graph, do the same as line 2 where you find all reachable nodes. This will get all nodes that can reach n in $\mathcal{O}(\OOG{|N|+|E|})$.

Intersection on line 5: Goes through all of $S$ and $T$ and adds nodes that are in both sets. This is $\mathcal{O}(\OOG{|N|})$ as worst-case, all nodes are in both sets, so we must traverse the sets fully.

Traverse paths of lines 6-10: For every node in $B$, which we determined worst-case is $|N|$ nodes, we must traverse all paths, which can again be accomplished using DFS, which is $\mathcal{O}(\OOG{|N|+|E|})$. Thus the complexity here is $\mathcal{O}(\OOG{|N|^2+|N||E|})$

Removing from B is an $\mathcal{O}(\OOG{|B|})$, which is worst-case $\mathcal{O}(\OOG{|N|})$, and checking if B is empty is $\mathcal{O}(\OOG{1})$.

Thus we can see, lines 6-10 are the largest complexity, so the overall complexity for this algorithm is $\mathcal{O}(\OOG{|N|^2+|N||E|})$

\end{questions}
For each question, explain why your algorithm is correct, what the complexity of your algorithm is, and which graph representation you use.
\end{problem}

\begin{problem}
Let $n$ be a positive integer and consider two $n \times n$ matrices $M_1$ and $M_2$. The \emph{Boolean matrix product} of $M_1$ and $M_2$, denoted by $M' \GETS M_1 \otimes M_2$, is the $n \times n$ matrix $M'$ in which $M'[i, j]$ is:
\[ M'[i, j] = (M_1[i, 0] \land M_2[0, j]) \lor (M_1[i, 1] \land M_2[1, j]) \lor \dots \lor (M_1[i, n-1] \land M_2[n-1,j]). \]

Now consider a directed graph $\Graph = (\Nodes, \Edges)$ implemented via the matrix representation $M$ with $n = \abs{\Nodes}$.
\begin{questions}
\item Let $M' = M \otimes M$. What does the value $M'[i,j]$ represent (when is it $\True$ and when is it $\False$)?

The value $M'[i, j]$ represents whether there exists a path of length 2 from node $i$ to node $j$ in the directed graph G = (N, E) represented by matrix M.

In other words, $M'[i, j]$ is true iff there exists a node $k$ such that $M[i, k]$ and $M[k, j]$ are true. This node $k$ is an intermediate node that connects $i$ and $j$.

If there is no node $k$ that can connect $i$ and $j$, then $M'[i, j]$ is false.

\item Consider paths of length $k$ in graph $G$. Provide an algorithm that uses the Boolean matrix product operations to compute a matrix $M_k$ such that, for every pair of nodes $n, m \in \Nodes$, $M_k[\ID{n}, \ID{m}]$ is $\True$ if and only if there is a path of length exact-$k$ from node $n$ to node $m$. Explain why your algorithm is correct and provide the complexity of your algorithm in terms of the number of Boolean matrix product operations used.

\textit{Hint}. One can design an algorithm that performs at-most $\OOG{\log_2(k)}$ Boolean matrix product operations.

Base case: If k = 1, then just return $M$ where $M_1[i,j]$ is 1 if there is an edge from node i to j. 

General case: If k > 1, recursively compute $M_{\lfloor{k/2}\rfloor}$, and then set $M_k$ to be the Boolean matrix product of $M_{\lfloor{k/2}\rfloor}$ and itself ($M_k = M_{\lfloor{k/2}\rfloor} \otimes M_{\lfloor{k/2}\rfloor}$).
If $k/2$ had a remainder, than after computing $M_{k2} = M_{\lfloor{k/2}\rfloor} \otimes M_{\lfloor{k/2}\rfloor}$, compute $M_k = M_{k2} \otimes M_1$.

In other words, the Boolean matrix product of $M_p \otimes M_r = M_{p+r}$.


\begin{myalgo}{\AName{BooleanProduct}($M, k$)}
  \IF{$k == 1$}
    \RETURN $M$
  \ENDIF
  \STATE $h = k//2$
  \STATE $result = \AName{BooleanProduct}(M, h) \otimes \AName{BooleanProduct}(M, h)$ \COMMENT{Get Boolean Product of matrix}
  \IF{$h \% 2 == 1$}  
    \STATE $result \otimes M$ \COMMENT{If needed to floor the value, then compute the result with $M_1$ to add 1 to path length}
  \ENDIF
  \RETURN $result$
\end{myalgo}


\item The \emph{transitive closure} of $\Graph$ is a graph $\Graph' = (\Nodes, \Edges')$ such that $(n, m) \in \Edges'$ if and only if there is a path from node $n$ to node $m$ in graph $\Graph$. Provide an algorithm that uses the Boolean matrix product operations to compute a matrix $M'$ that represents graph $\Graph'$. Explain why your algorithm is correct and provide the complexity of your algorithm.

1. Compute the Boolean matrix product $M' = M \otimes M$.

2. Store edges of $M'$ in a results Matrix

3. Repeat the matrix multiplication $M' = M' \otimes M$ until $M'$ stops changing. Keep storing the edges in results Matrrix between each multiplication.

4. The results Matrix $M'$ is the transitive closure of G.

Complexity is as large as the longest path since each matrix multiplication adds 1 to the path. This means $\OOG{\mathcal{O}(|N-1|)}$. 
This is added to the complexity of getting all edges in $M'$ and storing them in a resulting Matrix. Transferring this data is $\OOG{\mathcal{O}(|N|^2)}$ since you need to check every edge in $M'$.

\end{questions}
\end{problem}

\begin{problem}
Consider a directed graph $\Graph = (\Nodes, \Edges)$ and assume we have a weight function $\Weight : \Edges \rightarrow \{1, \dots, W\}$ with $W$ some maximum integer value $W$.
\begin{questions}
\item Assume $W = 1$ (all edges have weight $1$). Given node $n \in \Nodes$, provide an algorithm that can compute the shortest path from node $n$ to any other node $m$ in $\OOG{\abs{\Nodes} + \abs{\Edges}}$. In this case, the shortest path is the path with the fewest edges.
\item Given node $n \in \Nodes$, provide an algorithm that can compute the shortest path (in terms of the sum of the weights of edges on the path) from node $n$ to any other node $m$ in $\OOG{\abs{\Nodes} + W\abs{\Edges}}$.
\item Given node $n \in \Nodes$, provide an algorithm that can compute the shortest path (in terms of the sum of the weights of edges on the path) from node $n$ to any other node $m$ in $\OOG{W\abs{\Nodes} + \abs{\Edges}}$.
\end{questions}
For each question, explain why your algorithm is correct, why your algorithm achieves the stated complexity, and which graph representation you use.
\end{problem}

\SUBMITMSG{}
\DEFAULTGRADING{}

\end{document}